
#### 并发编程Bug的源头
* 缓存导致的可见性问题
* 线程切换带来的原子性问题
* 编译优化带来的有序性问题

Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法
这些方法包括volatile、synchronize和final三个关键字以及六项Happens-Before规则
volatile
 被volatile修饰的变量不写入缓存，且不参与重排序，这就解决了可见性与有序性的问题，
 但这是否保证了线程安全呢？答案是否定的，volatile无法保证原子性--引起并发过程中Bug的另一个源头。

Happens-Before规则
 所描述的是：先后发生的两个操作，其结果必须也体现操作的先后顺序，即： 前一个操作的结果对后续操作是可见的 。